# Malware Simulation – HTTP Tunneling

This part demonstrates that how an attacker with the help of insider threat can bypass basic functionality of firewalls and exchange data within normal HTTP traffic to avoid detection.

---

## Objective
- Simulate a persistent HTTP-based reverse shell that operates over port 80
- Allow full shell command execution and file transfers (upload/download)

---

## Files Involved

- `serverhttp_real.py` – Server (attacker side)
- `victimhttp_real.py` – Client (victim machine)

> Location in repo:
```
CyberFortify-Fyp/Red_team/Malware_codes/
```

---

## Technique Summary

| Aspect           | Detail                                                   |
|------------------|----------------------------------------------------------|
| Protocol         | HTTP (port 80)                                           |
| Beacon Interval  | 20 seconds (configurable)                                |
| Payload          | Commands and file data encoded with Base64               |
| Capabilities     | Shell execution, file upload/download                    |

---

## Implementation

1. **Victim** continuously polls `http://<attacker-ip>/poll` every 20s for commands.
2. **Attacker** injects commands using a Flask web server (`serverhttp_real.py`).
3. Victim executes commands and Base64-encodes results or files.
4. Output is POSTed to `/submit` and printed on attacker's terminal.

![HTTP Tunnel Shell](/assets/screenshots/http_tunnel/http_tunnel1.png)
![HTTP Tunnel Shell](/assets/screenshots/http_tunnel/http_tunnel2.png)

---

## Detection

- Firewall logs the outgoing unusual communication but shows service as HTTP
- Manual review can reveal that this is abnormal communication

![HTTP Tunnel Logs](/assets/screenshots/http_tunnel/tunnellog1.png)

---
